<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Jewelled Red Rose</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2575.4">
  <style>
    body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    #ui-overlay {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        pointer-events: none;
    }
    .controls-hint {
        font-size: 0.8rem;
        opacity: 0.7;
    }
    #copy-btn {
        position: absolute;
        bottom: 20px;
        right: 20px;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        cursor: pointer;
        backdrop-filter: blur(5px);
        border-radius: 5px;
        transition: all 0.3s;
        pointer-events: auto;
    }
    #copy-btn:hover {
        background: rgba(255, 0, 0, 0.4);
        border-color: #ff3333;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="ui-overlay">
    <h2>The Crimson Crystal Rose</h2>
    <p class="controls-hint">Click &amp; Drag to Rotate | Scroll to Zoom</p>
  </div>

  <button id="copy-btn" onclick="copyToClipboard()">Copy Code</button>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    let scene, camera, renderer, controls;
    let sparkleMaterial;

    function init() {
      // Scene & Camera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 10);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.toneMapping = THREE.ReinhardToneMapping;
      document.body.appendChild(renderer.domElement);

      // Lights (tuned and layered)
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambientLight);

      const pointLight1 = new THREE.PointLight(0xff3366, 1.6); // warm rose highlight
      pointLight1.position.set(4, 5, 4);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0xffffff, 0.9); // fill
      pointLight2.position.set(-5, 2, -5);
      scene.add(pointLight2);

      const rim = new THREE.DirectionalLight(0xffccd6, 0.4); // soft rim/back light
      rim.position.set(-1, 2, 3);
      scene.add(rim);

      // Create the Rose group
      const roseGroup = new THREE.Group();

      // Materials
      const petalMat = new THREE.MeshPhysicalMaterial({
        color: 0xcc1144,
        metalness: 0.5,
        roughness: 0.15,
        transmission: 0.15,
        thickness: 0.4,
        clearcoat: 0.9,
        clearcoatRoughness: 0.05,
        emissive: 0x220011
      });

      const stemMat = new THREE.MeshStandardMaterial({
        color: 0x003311,
        metalness: 0.6,
        roughness: 0.25
      });

      // Procedural Petals (lower polycount and fewer petals)
      const PETAL_COUNT = 18;
      for (let i = 0; i < PETAL_COUNT; i++) {
        const layer = Math.floor(i / 6);
        // keep low-poly faceted look (detail 0) and slightly smaller geometry
        const petalGeo = new THREE.IcosahedronGeometry(1.1, 0);
        const petal = new THREE.Mesh(petalGeo, petalMat);

        // Scale and shape the petals (thinner)
        petal.scale.set(0.55 + layer * 0.18, 0.08, 0.35 + layer * 0.12);

        // Position in a spiral
        const angle = i * (Math.PI * 2 / 6) + (layer * 0.45);
        const radius = 0.18 + (layer * 0.36);

        petal.position.x = Math.cos(angle) * radius;
        petal.position.z = Math.sin(angle) * radius;
        petal.position.y = layer * 0.28;

        petal.rotation.y = -angle;
        petal.rotation.z = 0.45 + (layer * 0.18);

        roseGroup.add(petal);
      }

      // Stem (reduced radial segments)
      const stemGeo = new THREE.CylinderGeometry(0.08, 0.12, 8, 6, 4);
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = -4;
      roseGroup.add(stem);

      // Leaves (low-poly)
      for(let j = 0; j < 2; j++) {
        const leafGeo = new THREE.IcosahedronGeometry(0.7, 0);
        const leaf = new THREE.Mesh(leafGeo, stemMat);
        leaf.scale.set(0.9, 0.08, 0.45);
        leaf.position.y = -2 - (j * 2);
        leaf.position.x = j % 2 === 0 ? 0.7 : -0.7;
        leaf.rotation.z = j % 2 === 0 ? 0.45 : -0.45;
        roseGroup.add(leaf);
      }

      scene.add(roseGroup);
      roseGroup.position.y = 1;

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.6;

      // Add glittering 3D text near base of the stem
      const loader = new FontLoader();
      loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
        const textGeo = new TextGeometry('Love you Twove', {
          font: font,
          size: 0.6,
          height: 0.06,
          curveSegments: 6,
          bevelEnabled: true,
          bevelThickness: 0.02,
          bevelSize: 0.02,
          bevelSegments: 3
        });

        textGeo.computeBoundingBox();
        const textWidth = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;

        const textMat = new THREE.MeshPhysicalMaterial({
          color: 0xff77aa,
          metalness: 0.6,
          roughness: 0.15,
          emissive: 0x220011,
          clearcoat: 1.0,
          clearcoatRoughness: 0.03
        });

        const textMesh = new THREE.Mesh(textGeo, textMat);
        // position slightly above the bottom of the stem and centered
        textMesh.position.set(-textWidth / 2 + 0.2, -6.4, 0.3);
        textMesh.rotation.x = -0.15; // gentle tilt
        textMesh.rotation.y = 0.25; // small angle so it reads nicely
        scene.add(textMesh);

        // Create sparkling points using the text geometry vertex positions
        const posAttr = textGeo.attributes.position;
        const sparklePositions = new Float32Array(posAttr.count * 3);
        for (let i = 0; i < posAttr.count; i++) {
          sparkIdx = i * 3;
          // copy vertex and add small random offset to spread sparkles
          sparklePositions[sparkIdx] = posAttr.getX(i) - textWidth / 2 + 0.2 + (Math.random() - 0.5) * 0.02;
          sparklePositions[sparkIdx + 1] = posAttr.getY(i) - 6.4 + (Math.random() - 0.5) * 0.02;
          sparklePositions[sparkIdx + 2] = posAttr.getZ(i) + 0.3 + (Math.random() - 0.5) * 0.02;
        }

        const sparkleGeo = new THREE.BufferGeometry();
        sparkleGeo.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));

        sparkleMaterial = new THREE.PointsMaterial({
          color: 0xffa3c1,
          size: 0.035,
          transparent: true,
          opacity: 0.95,
          depthWrite: false
        });

        const sparkles = new THREE.Points(sparkleGeo, sparkleMaterial);
        scene.add(sparkles);
      });

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(time) {
      requestAnimationFrame(animate);
      const t = time * 0.001;
      if (controls) controls.update();
      // animate sparkle size to glitter
      if (sparkleMaterial) {
        sparkleMaterial.size = 0.03 + 0.01 * Math.sin(t * 8.0);
        sparkleMaterial.opacity = 0.85 + 0.15 * (0.5 + 0.5 * Math.sin(t * 5.0));
      }
      renderer.render(scene, camera);
    }

    // Copy functionality (modern API with fallback)
    window.copyToClipboard = async function() {
      const html = document.documentElement.outerHTML;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(html);
          alert('HTML Code copied to clipboard!');
        } catch (err) {
          fallbackCopy(html);
        }
      } else {
        fallbackCopy(html);
      }
    }

    function fallbackCopy(text) {
      const el = document.createElement('textarea');
      el.value = text;
      el.setAttribute('readonly', '');
      el.style.position = 'absolute';
      el.style.left = '-9999px';
      document.body.appendChild(el);
      el.select();
      try {
        document.execCommand('copy');
        alert('HTML Code copied to clipboard!');
      } catch (err) {
        alert('Copy failed. Please select and copy manually.');
      }
      document.body.removeChild(el);
    }

    init();
    animate();
  </script>
</body>
</html>